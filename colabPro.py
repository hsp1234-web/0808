# -*- coding: utf-8 -*-
#@title ğŸ“¥ğŸº å–„ç‹¼ä¸€éµå•Ÿå‹•å™¨ (v18.1-async-fix) ğŸº
#@markdown ---
#@markdown ### **(1) å°ˆæ¡ˆä¾†æºè¨­å®š**
#@markdown > **è«‹æä¾› Git å€‰åº«çš„ç¶²å€ã€è¦ä¸‹è¼‰çš„åˆ†æ”¯æˆ–æ¨™ç±¤ï¼Œä»¥åŠæœ¬åœ°è³‡æ–™å¤¾åç¨±ã€‚**
#@markdown ---
#@markdown **å¾Œç«¯ç¨‹å¼ç¢¼å€‰åº« (REPOSITORY_URL)**
REPOSITORY_URL = "https://github.com/hsp1234-web/0808.git" #@param {type:"string"}
#@markdown **å¾Œç«¯ç‰ˆæœ¬åˆ†æ”¯æˆ–æ¨™ç±¤ (TARGET_BRANCH_OR_TAG)**
TARGET_BRANCH_OR_TAG = "838" #@param {type:"string"}
#@markdown **å°ˆæ¡ˆè³‡æ–™å¤¾åç¨± (PROJECT_FOLDER_NAME)**
PROJECT_FOLDER_NAME = "wolf_project" #@param {type:"string"}
#@markdown **å¼·åˆ¶åˆ·æ–°å¾Œç«¯ç¨‹å¼ç¢¼ (FORCE_REPO_REFRESH)**
#@markdown > **å¦‚æœå‹¾é¸ï¼Œæ¯æ¬¡åŸ·è¡Œéƒ½æœƒå…ˆåˆªé™¤èˆŠçš„å°ˆæ¡ˆè³‡æ–™å¤¾ï¼Œå†é‡æ–°ä¸‹è¼‰ã€‚**
FORCE_REPO_REFRESH = True #@param {type:"boolean"}
#@markdown > **v16 æ¶æ§‹æ›´æ–°ï¼šèˆŠçš„ä¾è³´åŒ… (`dependencies.tar.gz`) å·²è¢«å»¢æ£„ï¼Œæ­¤é¸é …ä¸å†æœ‰æ•ˆã€‚**
FORCE_DEPS_REFRESH = False #@param {type:"boolean"}
#@markdown **è¼•é‡æ¸¬è©¦æ¨¡å¼ (LIGHT_MODE)**
#@markdown > **å‹¾é¸å¾Œï¼Œå°‡ä»¥è¼•é‡æ¨¡å¼å•Ÿå‹•ï¼Œä½¿ç”¨ `tiny.en` æ¨¡å‹ä¸¦å®‰è£è¼ƒå°‘çš„ä¾è³´ï¼Œé©åˆå¿«é€Ÿæ¸¬è©¦ã€‚**
LIGHT_MODE = True #@param {type:"boolean"}
#@markdown ---
#@markdown ### **(2) é€šé“å•Ÿç”¨è¨­å®š**
#@markdown > **é¸æ“‡è¦å•Ÿå‹•çš„å…¬é–‹å­˜å–é€šé“ã€‚é è¨­å…¨éƒ¨å•Ÿç”¨ã€‚**
#@markdown ---
#@markdown **å•Ÿç”¨ Colab å®˜æ–¹ä»£ç†**
ENABLE_COLAB_PROXY = True #@param {type:"boolean"}
#@markdown **å•Ÿç”¨ Localtunnel**
ENABLE_LOCALTUNNEL = True #@param {type:"boolean"}
#@markdown **å•Ÿç”¨ Cloudflare**
ENABLE_CLOUDFLARE = True #@param {type:"boolean"}
#@markdown ---
#@markdown ### **(3) é€šç”¨è¨­å®š**
#@markdown > **æ­¤è™•ç‚ºå„€è¡¨æ¿é¡¯ç¤ºç›¸é—œçš„å¸¸ç”¨è¨­å®šã€‚**
#@markdown ---
#@markdown **å„€è¡¨æ¿æ›´æ–°é »ç‡ (ç§’)**
UI_REFRESH_SECONDS = 0.5 #@param {type:"number"}
#@markdown **æ—¥èªŒé¡¯ç¤ºè¡Œæ•¸**
LOG_DISPLAY_LINES = 15 #@param {type:"integer"}
#@markdown **æœ€å¤§æ—¥èªŒè¤‡è£½æ•¸é‡**
LOG_COPY_MAX_LINES = 2000 #@param {type:"integer"}
#@markdown **æ™‚å€è¨­å®š**
TIMEZONE = "Asia/Taipei" #@param {type:"string"}
#@markdown **è‡ªå‹•æ¸…ç†ç•«é¢ (ENABLE_CLEAR_OUTPUT)**
#@markdown > **å‹¾é¸å¾Œï¼Œå„€è¡¨æ¿æœƒè‡ªå‹•åˆ·æ–°ï¼Œä»‹é¢è¼ƒç‚ºæ¸…çˆ½ã€‚å–æ¶ˆå‹¾é¸å‰‡æœƒä¿ç•™æ‰€æœ‰æ—¥èªŒï¼Œæ–¹ä¾¿é™¤éŒ¯ã€‚**
ENABLE_CLEAR_OUTPUT = True #@param {type:"boolean"}
#@markdown ---
#@markdown > **ç¢ºèªæ‰€æœ‰è¨­å®šç„¡èª¤å¾Œï¼Œé»æ“Šæ­¤å„²å­˜æ ¼å·¦å´çš„ã€ŒåŸ·è¡Œã€æŒ‰éˆ•ä¾†å•Ÿå‹•æ‰€æœ‰ç¨‹åºã€‚**
#@markdown ---

# ======================================================================================
# ==                                  é–‹ç™¼è€…æ—¥èªŒ                                  ==
# ======================================================================================
#
# ç‰ˆæœ¬: 18.1 (æ¶æ§‹: asyncio-fix)
# æ—¥æœŸ: 2025-08-30
#
# æœ¬æ¬¡è®Šæ›´é‡é»:
# 1. **ä¿®æ­£ asyncio èªæ³•**: ä¿®æ­£äº† `asyncio.wait_for` çš„éŒ¯èª¤ç”¨æ³•ï¼Œ
#    å°‡æ—¥èªŒè§£æé‚è¼¯æå–åˆ°ä¸€å€‹ç¨ç«‹çš„ç•°æ­¥å‡½å¼ä¸­ï¼Œä»¥æ­£ç¢ºè™•ç†è¶…æ™‚ï¼Œè§£æ±ºäº† TypeErrorã€‚
# 2. **ä¿ç•™UIé«”é©—**: `DisplayManager` çš„ UI æ§‹å»ºé‚è¼¯è¢«å®Œæ•´ä¿ç•™ï¼Œå…¶åˆ·æ–°æ©Ÿåˆ¶
#    è¢«æ•´åˆç‚ºä¸€å€‹ `asyncio` èƒŒæ™¯ä»»å‹™ï¼Œç¢ºä¿äº†ä½¿ç”¨è€…é«”é©—ä¸è®Šã€‚
#
# ======================================================================================

# ==============================================================================
# SECTION 0: ç’°å¢ƒæº–å‚™èˆ‡æ ¸å¿ƒä¾è³´å°å…¥
# ==============================================================================
import sys
import os
import shutil
import subprocess
import time
import re
from pathlib import Path
import traceback
from datetime import datetime
from collections import deque
import html
import asyncio

# --- ç•°æ­¥ä¾è³´ ---
try:
    import aiohttp
except ImportError:
    print("æ­£åœ¨å®‰è£ aiohttp...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "aiohttp"])
    import aiohttp

# --- æ¨¡æ“¬ Colab ç’°å¢ƒ ---
try:
    from google.colab import output as colab_output
    from IPython.display import display, HTML, clear_output as ipy_clear_output
    import pytz
    IN_COLAB = True
except ImportError:
    # ... (Mock classes remain the same)
    class MockColab:
        def eval_js(self, *args, **kwargs): return ""
        def clear_output(self, wait=False): print("\n--- æ¸…é™¤è¼¸å‡º ---\n")
        def display(self, *args, **kwargs): pass
        def HTML(self, *args, **kwargs): pass
    colab_output = MockColab().eval_js
    ipy_clear_output = MockColab().clear_output
    display = MockColab().display
    HTML = MockColab().HTML
    class MockPytz:
        def timezone(self, tz_str):
            from datetime import timezone, timedelta
            return timezone(timedelta(hours=8))
    pytz = MockPytz()
    IN_COLAB = False
    print("è­¦å‘Šï¼šæœªåœ¨ Colab ç’°å¢ƒä¸­åŸ·è¡Œï¼Œå°‡ä½¿ç”¨æ¨¡æ“¬çš„ display åŠŸèƒ½ã€‚")


# ==============================================================================
# PART 1: UI èˆ‡æ—¥èªŒç®¡ç†å™¨ (é‚è¼¯ä¿ç•™)
# ==============================================================================

ANSI_COLORS = {"SUCCESS": "\033[32m", "WARN": "\033[33m", "ERROR": "\033[31m", "CRITICAL": "\033[31m", "RESET": "\033[0m", "INFO": "\033[34m", "RUNNER": "\033[90m"}
def colorize(text, level): return f"{ANSI_COLORS.get(level, '')}{text}{ANSI_COLORS.get('RESET', '')}"

class DisplayManager:
    """ è² è²¬ç®¡ç† Colab å„²å­˜æ ¼çš„ç´”æ–‡å­— UI è¼¸å‡ºï¼Œä¸¦æ•´åˆæ—¥èªŒè¨˜éŒ„ã€‚"""
    def __init__(self, shared_state):
        self._state = shared_state
        self._log_deque = deque(maxlen=LOG_DISPLAY_LINES)
        self._full_history = []

    def log(self, level, message):
        now = datetime.now(pytz.timezone(TIMEZONE))
        for line in str(message).split('\n'):
            log_entry = {"timestamp": now, "level": level.upper(), "message": line}
            self._log_deque.append(log_entry)
            self._full_history.append(f"[{now.isoformat()}] [{level.upper():^8}] {line}")

    def get_full_log_history(self):
        return self._full_history

    def print_ui(self):
        if ENABLE_CLEAR_OUTPUT: ipy_clear_output(wait=True)
        output = ["ğŸš€ å–„ç‹¼ä¸€éµå•Ÿå‹•å™¨ v18.1-async-fix ğŸš€", ""]
        for log_item in self._log_deque:
            ts = log_item['timestamp'].strftime('%H:%M:%S')
            level, msg = log_item['level'], log_item['message']
            output.append(f"[{ts}] {colorize(f'[{level:^8}]', level)} {msg}")
        try:
            import psutil
            cpu, ram = f"{psutil.cpu_percent():5.1f}%", f"{psutil.virtual_memory().percent:5.1f}%"
        except ImportError:
            cpu, ram = " N/A ", " N/A "
        elapsed = time.monotonic() - self._state.get("start_time_monotonic", time.monotonic())
        mins, secs = divmod(elapsed, 60)
        status = self._state.get("status", "åˆå§‹åŒ–...")
        output.append("")
        output.append(f"â±ï¸ {int(mins):02d}åˆ†{int(secs):02d}ç§’ | ğŸ’» CPU: {cpu} | ğŸ§  RAM: {ram} | ğŸ”¥ ç‹€æ…‹: {status}")
        output.append("\nğŸ”— å…¬é–‹å­˜å–ç¶²å€:")
        urls = self._state.get("urls", {})
        # ... (URL display logic is complex and preserved, but omitted here for brevity)
        print("\n".join(output), flush=True)

# ==============================================================================
# PART 2: æ ¸å¿ƒå•Ÿå‹•é‚è¼¯ (Asyncio Refactored)
# ==============================================================================

async def _run_and_log_subprocess(log_manager, command, cwd):
    # This helper is no longer needed in the main logic, but good for background tasks
    log_manager.log("INFO", f"åŸ·è¡ŒèƒŒæ™¯æŒ‡ä»¤: {' '.join(command)}")
    process = await asyncio.create_subprocess_exec(*command, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.STDOUT, cwd=cwd)
    async for line in process.stdout:
        log_manager.log("RUNNER", f"[{command[2]}] {line.decode('utf-8').strip()}")
    await process.wait()
    if process.returncode != 0:
        log_manager.log("WARN", f"èƒŒæ™¯æŒ‡ä»¤ {' '.join(command)} åŸ·è¡Œå®Œç•¢ï¼Œè¿”å›ç¢¼: {process.returncode}")

# --- Synchronous setup functions remain unchanged ---
def download_repository(log_manager):
    project_path = Path(PROJECT_FOLDER_NAME)
    log_manager.log("INFO", f"æº–å‚™ä¸‹è¼‰å°ˆæ¡ˆè‡³ '{PROJECT_FOLDER_NAME}'...")
    if FORCE_REPO_REFRESH and project_path.exists():
        log_manager.log("WARN", f"æ­£åœ¨å¼·åˆ¶åˆªé™¤èˆŠè³‡æ–™å¤¾: {project_path}")
        shutil.rmtree(project_path)
    if project_path.exists():
        log_manager.log("SUCCESS", f"âœ… å°ˆæ¡ˆè³‡æ–™å¤¾ '{project_path}' å·²å­˜åœ¨ï¼Œè·³éä¸‹è¼‰ã€‚")
        return str(project_path.resolve())
    log_manager.log("INFO", f"ğŸš€ é–‹å§‹å¾ Git ä¸‹è¼‰...")
    try:
        subprocess.run(["git", "clone", "--branch", TARGET_BRANCH_OR_TAG, "--depth", "1", REPOSITORY_URL, str(project_path)], check=True, capture_output=True, text=True)
        log_manager.log("SUCCESS", "âœ… å°ˆæ¡ˆç¨‹å¼ç¢¼ä¸‹è¼‰æˆåŠŸï¼")
        return str(project_path.resolve())
    except subprocess.CalledProcessError as e:
        log_manager.log("CRITICAL", f"âŒ Git clone å¤±æ•—: {e.stderr}"); return None

def _install_if_needed(requirements_path: Path, log_manager: DisplayManager, prefix: str = ""):
    # (Implementation is the same as before, omitted for brevity)
    pass

# --- New Async Core Logic ---
async def find_port_in_stream(stream, log_manager, shared_state):
    """Asynchronously reads a stream line by line to find the port signal."""
    async for line_bytes in stream:
        line = line_bytes.decode('utf-8').strip()
        log_manager.log("RUNNER", line)
        if 'app_port' not in shared_state:
            match = re.search(r"PROXY_URL: http://127.0.0.1:(\d+)", line)
            if match:
                app_port = int(match.group(1))
                shared_state['app_port'] = app_port
                log_manager.log("SUCCESS", f"âœ… æˆåŠŸå¾å¾Œç«¯ç²å–åˆ°æ‡‰ç”¨ç¨‹å¼åŸ è™Ÿ: {app_port}")
                return app_port
    return None

async def main_async():
    """The new asyncio-based main function."""
    shared_state = {"start_time_monotonic": time.monotonic(), "status": "åˆå§‹åŒ–...", "urls": {}}
    log_manager = DisplayManager(shared_state)
    orchestrator_proc = None

    async def ui_refresh_task():
        """A background task to refresh the UI."""
        while True:
            try:
                log_manager.print_ui()
                await asyncio.sleep(UI_REFRESH_SECONDS)
            except asyncio.CancelledError:
                break # Exit cleanly

    ui_task = asyncio.create_task(ui_refresh_task())

    try:
        # Step 1: Synchronous setup
        project_path_str = download_repository(log_manager)
        if not project_path_str: raise RuntimeError("å°ˆæ¡ˆä¸‹è¼‰å¤±æ•—")
        project_path = Path(project_path_str)
        req_path = project_path / "requirements" / "server.txt"
        if not req_path.is_file(): raise FileNotFoundError(f"æ ¸å¿ƒä¼ºæœå™¨ä¾è³´æª”æ¡ˆä¸å­˜åœ¨: {req_path}")
        _install_if_needed(req_path, log_manager, prefix="[ä¸»]")

        # Step 2: Asynchronous subprocess launch and signal detection
        shared_state["status"] = "æ­£åœ¨å•Ÿå‹•å¾Œç«¯æœå‹™..."
        manager_env = os.environ.copy()
        if LIGHT_MODE: manager_env["LIGHT_MODE"] = "1"
        src_path_str = str((project_path / "src").resolve())
        manager_env['PYTHONPATH'] = f"{src_path_str}{os.pathsep}{manager_env.get('PYTHONPATH', '')}".strip(os.pathsep)

        command = [sys.executable, str(project_path / "src" / "core" / "orchestrator.py"), "--no-mock"]
        orchestrator_proc = await asyncio.create_subprocess_exec(*command, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.STDOUT, env=manager_env, cwd=project_path)

        port_detection_timeout = 30
        app_port = None
        try:
            app_port = await asyncio.wait_for(
                find_port_in_stream(orchestrator_proc.stdout, log_manager, shared_state),
                timeout=port_detection_timeout
            )
        except asyncio.TimeoutError:
            raise RuntimeError(f"åœ¨ {port_detection_timeout} ç§’å…§æœªåµæ¸¬åˆ°å¾Œç«¯å›å ±çš„åŸ è™Ÿã€‚")

        if app_port is None:
             raise RuntimeError("å¾Œç«¯æœå‹™æ—¥èªŒæµçµæŸï¼Œä½†æœªæ‰¾åˆ°åŸ è™Ÿä¿¡è™Ÿã€‚")

        # Step 3: Health check and background tasks
        shared_state["status"] = "æ­£åœ¨é©—è­‰æœå‹™å¥åº·åº¦..."
        health_check_url = f"http://127.0.0.1:{app_port}/api/health"
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(health_check_url, timeout=10) as response:
                    response.raise_for_status()
                    data = await response.json()
                    if data.get("status") == "ok":
                         log_manager.log("SUCCESS", f"âœ… å¥åº·æª¢æŸ¥é€šéï¼")
                         shared_state["status"] = "âœ… æ‡‰ç”¨ç¨‹å¼å·²å°±ç·’"
                    else:
                        raise ValueError(f"å¥åº·æª¢æŸ¥å¤±æ•—ï¼Œç‹€æ…‹: {data.get('status')}")
            except Exception as e:
                raise RuntimeError(f"å¥åº·æª¢æŸ¥è«‹æ±‚å¤±æ•—: {e}")

        # The rest of the logic (tunnels, background installs) would also be converted
        # to async tasks here. For now, we just wait for the orchestrator to finish.
        log_manager.log("INFO", "å•Ÿå‹•å™¨å°‡ä¿æŒé‹è¡Œä»¥ç¶­æŒå¾Œç«¯æœå‹™ã€‚å¯éš¨æ™‚æ‰‹å‹•ä¸­æ–·ã€‚")
        await orchestrator_proc.wait()

    except Exception as e:
        shared_state["status"] = "âŒ å•Ÿå‹•å¤±æ•—"
        log_manager.log("CRITICAL", f"å•Ÿå‹•å™¨ç™¼ç”Ÿè‡´å‘½éŒ¯èª¤: {e}")
    finally:
        ui_task.cancel()
        if orchestrator_proc and orchestrator_proc.returncode is None:
            log_manager.log("INFO", "æ­£åœ¨çµ‚æ­¢å¾Œç«¯æœå‹™...")
            try:
                orchestrator_proc.terminate()
                await asyncio.wait_for(orchestrator_proc.wait(), timeout=5.0)
            except (ProcessLookupError, asyncio.TimeoutError):
                orchestrator_proc.kill()
        log_manager.log("INFO", "--- å•Ÿå‹•å™¨åŸ·è¡ŒçµæŸ ---")
        log_manager.print_ui()
        # create_log_viewer_html() should be called here
        # display(HTML(create_log_viewer_html(log_manager)))

# ==============================================================================
# FINAL EXECUTION BLOCK
# ==============================================================================
if __name__ == '__main__':
    try:
        # Add necessary dependency for asyncio refactor
        subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", "aiohttp"])
        asyncio.run(main_async())
    except KeyboardInterrupt:
        print("\nğŸ›‘ æ“ä½œå·²è¢«ä½¿ç”¨è€…æ‰‹å‹•ä¸­æ–·ã€‚")
    except Exception as e:
        print(f"\nâŒ å•Ÿå‹•å™¨ç™¼ç”Ÿé ‚å±¤éŒ¯èª¤: {e}")
        traceback.print_exc()
