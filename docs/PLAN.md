> **[Jules's Note]**
> 本文件詳細記錄了從 V33 架構演進至「監督者/工作者」模型的偵錯歷程與設計思路。此模型是「預烘烤環境」架構的前身，但已被其完全取代。本文件僅供歷史參考，最新的架構設計請參閱根目錄下的 `research_0808.md` 文件。

---

# 架構重構與健壯性強化計畫書 (V1.0)

**文件目的**: 本文件旨在完整記錄 `local_run.py` 啟動失敗問題的偵錯歷程，梳理在解決問題過程中討論的數個架構方案，並詳細闡述最終選定的「引導加載器」架構的設計細節與實施計畫。這將作為後續開發工作的核心指導文件。

---

## 1. 當前問題與偵錯歷程回顧

### 1.1. 問題陳述

最初的任務目標是強化 `local_run.py` 腳本，為其增加結構化日誌和更可靠的資料庫心跳檢查。然而，在實施後，執行 `python local_run.py` 總是遭遇「看門狗超時」的錯誤，其最終原因始終指向「在 status_updates 表中找不到 'last_heartbeat' 記錄」。這表示後端服務雖然啟動了，但其核心的心跳任務從未成功執行。

### 1.2. 螺旋式偵錯歷程

在定位問題的過程中，我們經歷了層層遞進的探索，並修復了多個潛藏的系統性問題：

1.  **依賴問題**: 發現 `local_run.py` 依賴的 `pytz` 未被安裝在執行環境中。
2.  **核心啟動器 BUG**: 發現 `scripts/launch.py` 仍在使用會導致「無聲掛起」的 `subprocess.Popen`，違反了 `BUG.md` 的歷史教訓。將其替換為 `subprocess.run` 後，`launch.py` 終於可以執行並產生日誌。
3.  **殭屍進程問題**: `launch.py` 成功執行後，暴露了因先前執行失敗而殘留的殭屍進程佔用 8080 埠號的問題。
4.  **測試框架問題**: 在嘗試用單元測試驗證核心邏輯時，發現 `tests/system_health_check.py` 存在斷言過時、日誌捕獲方式錯誤 (`capsys` vs `caplog`)、以及開發依賴未被正確安裝等多個問題。
5.  **探測器驗證成功**: 在修復了所有外圍問題後，我們建立了一個獨立的 `tools/heartbeat_probe.py` 探測器。**此探測器成功驗證了 `asyncio` 背景任務在當前環境中進行 `sqlite3` 寫入是完全可行的**。
6.  **最終結論**: 探測器的成功，與主程式的失敗形成了鮮明對比，最終將問題的根源精準地定位在 **FastAPI/Uvicorn 框架的應用生命週期管理**上。

---

## 2. 架構方案的討論與演進

基於上述結論，我們探討了多個旨在提升系統健壯性的架構方案。

*   **方案一：反應式健康檢查**: 透過改良 `lifespan` 事件，讓看門狗監控一個更明確的「應用就緒」狀態。
*   **方案二：解耦的「任務監督者」模式**: 將背景工作者與 API 伺服器徹底解耦為獨立的進程。
*   **方案三：線上健康端點**: 引入行業標準的 `/healthz` API 端點，讓應用程式自我宣告健康狀況。

在討論中，您提出了幾個至關重要的設計要求與限制：

*   **`colab_runner.py` 的核心地位**: 它必須保持為一個可被輕易複製、貼上到 Colab 儲存格中執行的獨立「橋樑」。
*   **極簡主義**: `colab_runner.py` 應只包含 UI 和使用者輸入邏輯，所有核心啟動、監控邏輯都應被剝離。
*   **架構偏好**: 您對方案二和方案三的「解耦」與「健康檢查」理念表示贊同。
*   **原生佇列**: 希望利用現有的資料庫（如 SQLite）來實現簡單的任務佇列功能，避免引入 Redis 等新的外部依賴。
*   **極致的容錯性**: 任何一個獨立的功能模組（如未來的網頁檢查器）的崩潰，都絕不能影響到主服務或其他模組的運行。

綜合以上所有因素，我們共同設計出了最終的解決方案。

---

## 3. 最終方案詳解：「引導加載器」架構

這套架構是我們討論的結晶，它完美地平衡了您的所有需求，特別是 `colab_runner.py` 的特殊限制。

### 3.1. 核心理念

`colab_runner.py` 的職責被壓縮到極致，成為一個「引導加載器」。它唯一的使命就是從 GitHub **下載**最新的程式碼，然後**執行**一個獨立的、真正的「中央監督者」腳本來啟動所有後端服務。

### 3.2. 組件職責詳解

1.  **`colab_runner.py` (引導加載器 + UI)**
    *   **UI 與參數**: 完整保留您設計的 `#@param` 使用者輸入選項和儀表板 UI。
    *   **核心邏輯**:
        *   **下載**: 執行 `git clone`，從指定的 Git 倉庫和分支下載最新的應用程式碼。
        *   **啟動**: 呼叫 `subprocess.run` 來啟動下載下來的 `scripts/supervisor.py`。
    *   **優勢**: 此檔案的邏輯極簡且穩定，未來後端架構的任何演進都無需修改此檔案。

2.  **`scripts/supervisor.py` (中央監督者)**
    *   **定位**: 作為一個獨立的檔案存在於專案倉庫中，是整個後端應用**唯一的啟動與監控中心**。
    *   **職責**:
        *   **啟動元件**: 負責以獨立的子進程方式，啟動所有「微核心元件」（如 API 伺服器、心跳工作者等）。
        *   **監控心跳**: 持續檢查資料庫中記錄的、來自每一個子進程的心跳時間戳。
        *   **故障恢復**: 當發現某個元件的心跳過期時，能獨立地終止並重啟該元件的進程，而不會影響其他正在運行的元件。

3.  **微核心元件 (Workers)**
    *   **定位**: 每一個背景任務都被封裝在自己的、極簡的 Python 腳本中 (e.g., `scripts/heartbeat_worker.py`)。
    *   **職責**: 每個工作者都只做一件事，並定期向資料庫中的 `status_updates` 表回報自己的心跳。

4.  **狀態資料庫 (`state.db`)**
    *   **定位**: 作為所有獨立進程之間通訊的「中央神經系統」。
    *   **功能**:
        *   **心跳中樞**: 記錄所有元件的獨立心跳。
        *   **任務佇列**: 可透過一個 `tasks` 表來實現簡單的、無需外部依賴的任務分派。

5.  **`local_run.py` (本地測試入口)**
    *   **職責**: 其職責被簡化為與 `colab_runner.py` 的第二步相同：直接呼叫 `scripts/supervisor.py` 來進行本地的整合測試。

---

## 4. 分階段實施計畫

為確保遷移過程的穩定，我們將分階段實施此新架構。

*   **第一階段：核心架構搭建與驗證** [已完成]
    1.  [已完成] 建立 `scripts/supervisor.py` 和 `scripts/heartbeat_worker.py` 的初始版本。
    2.  [已完成] 將 `main.py` 中的背景任務邏輯移除，使其成為一個純粹的 API 伺服器。
    3.  [已完成] 改造 `local_run.py`，使其呼叫 `supervisor.py`，並驗證「監督者-API-工作者」這個新的多進程模式能夠成功運行。**此階段的目標是讓 `local_run.py` 首次成功跑通**。
*   **第二階段：`colab_runner.py` 適配**
    1.  在第一階段成功後，改造 `colab_runner.py`，將其核心邏輯替換為「下載並執行 `supervisor.py`」的引導加載器模式。
*   **第三階段：文件更新**
    1.  在所有功能驗證通過後，更新 `CHANGEL.md` 和 `BUG.md`，將這次成功的重構經驗記錄下來。
    2.  將本計畫文件 (`REFACTOR_PLAN.md`) 也一併存檔，作為永久的技術決策記錄。

---
---

## 5. V2.0 偵錯紀要：Heartbeat Worker 無聲啟動失敗問題

在 V1.0 架構實施後，儘管 `supervisor.py` 的設計避免了主應用程式的生命週期問題，但新的問題浮現：`heartbeat_worker.py` 行程無法啟動，並且沒有留下任何錯誤日誌，此現象被稱為「無聲失敗」。以下是為解決此問題而進行的詳細偵錯歷程。

### 5.1. 問題陳述

執行 `python local_run.py` 後，`supervisor.py` 成功啟動，API 伺服器也正常運行，但 `logs/heartbeat_worker.log` 始終為空。這表示 `heartbeat_worker.py` 子行程在啟動後立即退出，且未能執行任何 Python 程式碼。

### 5.2. 螺旋式偵錯歷程 (V2)

1.  **假設 1：子行程輸出死鎖**
    *   **現象**: `supervisor.py` 使用了 `subprocess.Popen`，但最初的實作是繼承父行程的 `stdout`/`stderr`，這可能導致管道阻塞。
    *   **嘗試**: 修改 `supervisor.py`，將子行程的輸出明確地重導向到獨立的日誌檔案。
    *   **結果**: 問題依舊。證明死鎖不是主要原因，但此修改提升了系統的健壯性。

2.  **假設 2：Python 依賴缺失**
    *   **現象**: API 伺服器曾因缺少 `uvicorn` 而失敗。`heartbeat_worker` 是否也缺少某個依賴？
    *   **嘗試**: 執行 `pip install -r requirements/base.txt` 安裝所有基礎依賴。
    *   **結果**: 問題依舊。`api_server` 正常啟動，但 `heartbeat_worker` 仍然失敗。

3.  **假設 3：檔案權限問題**
    *   **現象**: 子行程無法執行，可能是因為腳本檔案沒有執行權限。
    *   **嘗試**: 執行 `ls -l scripts/`，發現 `heartbeat_worker.py` 確實缺少執行權限 (`x`)。使用 `chmod +x scripts/*.py` 添加權限。
    *   **結果**: 問題依舊。這是一個令人困惑的結果，因為權限問題通常是無聲失敗的直接原因。

4.  **假設 4：Python 腳本內部錯誤**
    *   **現象**: 腳本可能在 `import` 階段就發生了無法被記錄的致命錯誤。
    *   **嘗試**:
        *   **A. 插入 `try...except` 區塊**: 修改 `heartbeat_worker.py`，用一個全域的 `try...except` 包圍所有 `import` 語句，並在 `except` 中將錯誤寫入一個獨立的偵錯日誌。
        *   **B. 簡化腳本**: 將 `heartbeat_worker.py` 的內容完全替換為一行 `print("hello")`。
    *   **結果**:
        *   **A 的結果**: 偵錯日誌**未被建立**，表示錯誤發生在 `try...except` 區塊執行之前。
        *   **B 的結果**: **成功！** 日誌中出現了 "hello"。這決定性地證明了問題**出在原始腳本的程式碼中**。

5.  **假設 5：特定程式碼行導致的語法或執行錯誤**
    *   **現象**: 在證明問題出在程式碼內部後，開始逐行還原程式碼並測試。
    *   **嘗試**:
        *   **A. 發現並修正語法錯誤**: 在一次 `replace_with_git_merge_diff` 操作中，意外地在 `heartbeat_worker.py` 中產生了重複的 `# -*- coding: utf-8 -*-` 宣告，這是一個會導致解釋器立即退出的致命語法錯誤。修正此問題。
        *   **B. 發現並修正編碼錯誤**: 懷疑 `print` 中文導致 `UnicodeEncodeError`，因此在 `supervisor.py` 中開啟日誌檔案時，明確指定 `encoding="utf-8"`。
    *   **結果**: 問題**依舊**。儘管這些都是真實存在的問題，但修復後 `heartbeat_worker` 仍然無法啟動。

6.  **假設 6：Python 解釋器環境問題 (使用者建議)**
    *   **現象**: 在所有程式碼層級的嘗試均告失敗後，採納了使用者提出的建議，使用 `pytest` 在隔離環境中進行測試。
    *   **嘗試**: 建立 `tests/test_heartbeat_worker_standalone.py`，直接在測試中用 `subprocess.run` 呼叫 `heartbeat_worker.py`。
    *   **結果**: **成功獲得明確的錯誤訊息！** `stderr` 中清楚地顯示：`FATAL: Failed to import DatabaseManager: No module named 'pytz'`。

### 5.3. 最終結論與待辦事項

`pytest` 的成功捕獲，揭示了問題的真正根源：**Python 環境不一致**。

儘管主環境中已安裝 `pytz`，但 `supervisor.py` 在啟動子行程時，所使用的 Python 解釋器 (`sys.executable`) 是一個未安裝任何依賴的、更底層的系統 Python。這導致 `heartbeat_worker.py` 在 `import` 階段因找不到 `pytz` 而失敗。

雖然嘗試將 `supervisor.py` 中的 `sys.executable` 改為 `python` (依賴 `PATH`)，但問題仍未解決，這表明沙箱環境中的 `PATH` 也指向了錯誤的 Python。

**此問題已超出程式碼修改的範疇，屬於執行環境的配置問題。**

**已完成的工作**:
1.  **`supervisor.py` 重構**: 解決了死鎖問題，確保了日誌記錄的健壯性。
2.  **`colab_runner.py` 建立**: 完成了一個功能完整的 Colab UI 引導加載器。
3.  **程式碼清理**: 對 `heartbeat_worker.py` 進行了重構，使其邏輯更清晰。

**交接事項 (給下一個助手)**:
*   **核心任務**: 解決 `supervisor.py` 無法在正確的虛擬環境中啟動子行程的問題。
*   **可能的解決方案**:
    1.  **修改啟動命令**: 在 `supervisor.py` 中，將啟動子行程的命令修改為 `[sys.executable, "-m", "scripts.heartbeat_worker"]` 或類似的形式，嘗試使用模組化執行。
    2.  **虛擬環境路徑**: 直接在 `supervisor.py` 中硬編碼或動態尋找正確的虛擬環境 Python 解釋器路徑來啟動子行程。
    3.  **啟動器腳本**: 建立一個 shell 腳本 (`run.sh`)，該腳本首先 `source` 虛擬環境的 `activate` 指令，然後再執行 `python scripts/supervisor.py`。讓 `local_run.py` 改為執行此 `run.sh` 腳本。

在解決此環境問題後，整個系統應能成功運行。
