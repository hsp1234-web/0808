# 關於檔案列表刷新後遺失問題的偵錯與分析總結

本文檔記錄了針對「網頁刷新後，已上傳的檔案紀錄消失」問題的完整偵錯過程、嘗試的解決方案、遇到的挑戰以及最終的結論。

## 1. 初始問題定義

使用者回報，當透過 Web UI 上傳檔案後，雖然檔案已成功儲存至 `uploads/` 目錄，但只要一重新整理頁面，UI 上的檔案列表就會被清空，造成資料遺失的錯覺。

## 2. 初步分析與解決方案構想

經過初步分析，我們確認了系統的設計是「以任務為中心」而非「以檔案為中心」。UI 列表的內容來自於資料庫中的「任務」記錄，而非直接讀取 `uploads/` 資料夾。如果一個檔案僅被上傳而未被處理（即未建立任務），它的記錄就不會存入資料庫，導致刷新後無法還原。

基於此，我們提出了第一個解決方案：**建立一個獨立的「檔案總管」功能**。

### 「檔案總管」方案計畫

-   **後端**：新增一個 `/api/list_files` API 端點，其功能為直接掃描 `uploads/` 目錄並回傳其中的檔案列表。
-   **前端**：在 `mp3.html` 中新增一個「檔案總管」UI 區塊，該區塊在頁面載入時呼叫 `/api/list_files`，並將返回的檔案動態渲染到畫面上。同時，為每個檔案項目提供「下載」、「刪除」、「送去轉錄」等操作按鈕。
-   **測試**：編寫一個 Playwright 端對端測試，用以驗證檔案的建立、列出、和刪除功能是否正常。

## 3. 實作與遭遇的頑固測試錯誤

我們按照計畫逐步實作了「檔案總管」功能。後端 API 和前端 UI 的基本程式碼都已完成。然而，在編寫 Playwright 自動化測試以驗證功能時，我們遇到了一個非常頑固且難以解釋的錯誤。

**核心症狀**：測試腳本可以在 `uploads/` 目錄中成功建立一個測試檔案，但後續的測試步驟中，Playwright 始終無法在前端 UI 上找到這個檔案對應的列表項目，導致測試因超時而失敗。

### 漫長的除錯之旅

為了解決這個問題，我們進行了一系列系統性的除錯：

1.  **確認依賴安裝**：最初測試因找不到 `@playwright/test` 模組而失敗。我們透過執行 `npm install` 和 `bun install` 解決了依賴問題。
2.  **確認伺服器運作**：我們發現 E2E 測試需要背景伺服器。我們找到了 `scripts/run_for_playwright.py` 腳本並在背景執行它。
3.  **除錯伺服器腳本**：發現伺服器腳本卡在安裝依賴階段。透過閱讀腳本，我們確認了它使用 `bun` 而非 `npm`，並在手動終止舊程序和安裝依賴後，成功啟動了伺服器。
4.  **修正測試腳本語法**：解決了因專案採用 ES Module 而導致的 `require is not defined` 和 `__dirname is not defined` 的語法問題。
5.  **隔離後端問題（突破點）**：為了判斷問題出在前端還是後端，我們在測試腳本中直接使用 `curl` 命令列工具去請求 `/api/list_files`。**結果證實，後端 API 運作完全正常**，它回傳了包含測試檔案的正確 JSON 資料。
6.  **隔離前端渲染問題**：既然後端正常且前端收到了資料，問題便直指前端的 DOM 渲染邏輯。我們將 `innerHTML` 的實作重構為更穩健的 `document.createElement`，但問題依舊。
7.  **最終除錯手段**：我們修改測試，讓它不再斷言元素可見，而是直接獲取整個列表的 `innerHTML` 並印出。結果顯示，列表的 `innerHTML` 始終是空的，證明了 DOM 沒有被成功渲染。

## 4. 使用者的洞見與方向轉變

在我們對這個渲染 Bug 束手無策時，使用者提出了關鍵性的回饋：**「我們是否不應該使用這麼複雜的檔案總管？」**

使用者建議，我們應該回歸問題的本質，即「讓已處理的任務記錄在刷新後能夠被還原」，而不是去新增一個全新的功能。

這個建議讓我們恍然大悟：**我們遇到的那個頑固的渲染 Bug，很可能就是導致原始問題（已完成任務列表刷新後消失）的真正元兇！** 現有的 `loadTaskHistory` 函式在試圖還原列表時，可能也因為同樣的渲染問題而失敗了。

## 5. 結論與最終狀態

根據使用者的指示，我們中止了所有的程式碼修改，並將這次寶貴的偵錯經驗記錄下來。

-   **最終結論**：問題的根源很可能是一個潛藏在前端 JavaScript 中的渲染錯誤，它阻礙了任何透過 `fetch` 非同步取得資料後對列表進行的 DOM 操作。
-   **已完成的工作**：
    -   新增了 `/api/list_files` 和 `/api/delete_file` 後端端點。
    -   在前端 `mp3.html` 中新增了「檔案總管」的 UI 和大部分邏輯。
    -   編寫了一個（雖然無法通過但極具診斷價值的）Playwright 測試案例。
-   **下一步（已中止）**：原定的下一步是集中火力解決這個核心的 DOM 渲染問題。

這次的偵錯過程雖然曲折，但最終成功地將問題範圍從一個模糊的「列表消失」現象，縮小並定位到一個具體的前端渲染 Bug，並驗證了後端 API 的正確性。

## 6. 架構層面的再分析與新策略

在對程式碼進行深度分析後，我們與使用者進行了進一步的架構討論，並得出了新的結論與執行策略。

### 6.1. 問題的再定義：從「程式錯誤」到「設計模式缺陷」

經過對 `mp3.html` 中 JavaScript 程式碼的仔細審查，我們發現：

-   程式碼本身並無明顯的語法錯誤。
-   DOM 元素的選取、`DOMContentLoaded` 的使用等都遵循了標準實踐。

這解釋了為何此 Bug 如此頑固。問題的根源很可能**不是一個具體的程式錯誤，而是一個脆弱的設計模式**。目前的模式允許多個不同的非同步操作（歷史紀錄載入、檔案總管、WebSocket 更新）各自獨立地、在無法預測的時間點去修改 DOM。這種高度耦合的模式在複雜介面中極易出錯，導致畫面渲染失敗。

### 6.2. 解決方案的探討

基於新的認識，我們探討了兩種層次的解決方案：

1.  **前端渲染重構（釜底抽薪）**：此方案旨在解決眼前的**畫面渲染**問題。核心思想是**將「資料狀態」與「畫面渲染」徹底分離**。
    -   **單一資料狀態 (State)**：在 JavaScript 中建立一個唯一的、可信的資料來源（State），用來存放所有列表的資料。
    -   **中央渲染函式 (Render)**：建立一個唯一的 `render()` 函式，其職責就是讀取 State 中的資料，並完整地重新繪製對應的 UI 組件。
    -   **資料獲取器 (Fetcher)**：將現有的 `fetch` 相關函式改造為單純的資料獲取器。它們獲取資料後，僅更新 State，然後呼叫 `render()` 函式來觸發畫面更新。
    -   **優點**：此模式使 UI 的更新變得可預測、穩定且極易除錯，能從根本上解決渲染失敗的問題。

2.  **後端統一介面架構（長遠演進）**：此方案由使用者提出，旨在解決**資料獲取**的複雜性，類似於 GraphQL 或 BFF 模式。
    -   **單一 API 端點**：後端提供一個統一的介面，前端透過一次請求就能獲取頁面所需的所有資料。
    -   **後端翻譯層**：後端負責解析前端的請求，並從多個內部資料來源（資料庫、其他服務）中組合資料。
    -   **優點**：大幅簡化前端的資料獲取邏輯，達成前後端的深度解耦，提升開發效率。

### 6.3. 最終決定的兩步走策略

我們一致認為，上述兩種方案分別解決了不同層面的問題，並且可以相輔相成。因此，我們制定了以下的兩步走策略：

1.  **第一步：穩定前端**：首先，我們將集中力量在前端實施**「狀態與渲染分離」**的重構。這個步驟的目標是快速、可靠地修復當前的渲染 Bug，讓「檔案總管」和「任務歷史紀錄」功能恢復正常。

2.  **第二步：優化後端**：在前端穩定運作的基礎上，未來可以再規劃進行後端的「統一介面架構」升級。屆時，由於前端已有穩定的渲染機制，切換到新的後端 API 將會非常順利。

這個策略旨在於「快速解決問題」和「追求長遠架構健康」之間取得平衡。本次提交將以此策略為基礎，更新本文件。

## 7. 重構實踐與新挑戰

根據已確定的「兩步走」策略，我們開始執行第一步：對 `mp3.html` 進行「狀態與渲染分離」的重構。

### 7.1. 透過測試重現 Bug

在修改任何程式碼之前，我們做的第一件事就是執行 `e2e-file-browser.spec.js` 測試，以確保能夠穩定地重現問題。

-   **進展**：我們成功地解決了測試環境的依賴和伺服器啟動問題，並最終**成功重現了核心錯誤**：測試腳本在 `uploads/` 目錄中建立了檔案，但前端介面未能渲染出該檔案，導致測試超時。
-   **意義**：這一步驗證了先前除錯摘要中的所有猜測，確認了我們的目標是正確的。

### 7.2. 初次重構的困難與反思

在確認 Bug 後，我們開始著手修改 `mp3.html` 的渲染邏輯。然而，這個過程並非一帆風順。

-   **遇到的困難**：我們多次嘗試使用 `replace_with_git_merge_diff` 工具來一次性地引入新的 `state` 物件和 `render()` 函式，並修改現有的 `loadFileBrowser` 函式。
-   **導致的錯誤**：這些嘗試幾乎全部失敗。失敗的原因在於，我們試圖在單一操作中修改過多的程式碼區塊。這使得 `SEARCH` 區塊的定位變得非常困難且容易出錯，導致工具無法正確應用變更。
-   **學到的教訓**：這次的失敗給我們帶來了寶貴的教訓——**重構必須以更小、更安全、更原子化的增量步驟進行**。試圖一次性完成大規模的程式碼替換，尤其是在一個龐大而複雜的單體 HTML 檔案中，風險極高且效率低下。

### 7.3. 當前狀態與下一步

-   **當前狀態**：我們已經深刻反省了先前的錯誤策略。為了確保成功，我們已將 `mp3.html` **完全還原到其最原始的狀態**，清除所有失敗的修改，準備重新開始。
-   **下一步**：我們將採取極度謹慎的策略，從一個完全不影響現有功能的修改開始：僅在 `<script>` 標籤的頂部宣告一個空的 `state` 物件和一個空的 `render()` 函式。在確認這一步成功後，再逐步將既有邏輯一點一點地遷移到新的模式中。
