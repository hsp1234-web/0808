# 鳳凰之心 - 開發經驗與教訓總結

本文件旨在沉澱「鳳凰之心」專案在開發過程中積累的核心經驗、遇到的關鍵挑戰，以及我們從成功與失敗中學到的寶貴教訓。這是一份動態的、持續更新的知識庫，希望能為未來的開發者提供指引，避免重蹈覆轍。

---

## 第一章：環境、工具鏈與依賴管理

### 1.1. 深刻教訓：永遠不要相信沙箱環境

我們在開發中遇到的最棘手、最隱蔽的問題，都源自於專案執行的沙箱環境與標準 Linux 環境的行為不一致。

*   **核心問題**: 在一個受限的沙箱環境中（可能基於 gVisor），我們發現任何包含 `subprocess.Popen` 呼叫的 Python 函式，都會在被呼叫時導致解譯器**無聲地掛起**。這個 BUG 極其隱蔽，因為它甚至在 `Popen` 程式碼被實際執行前就觸發，且不產生任何日誌。
*   **根本原因**: 這強烈暗示沙箱的系統呼叫攔截層在處理 Python 的 `fork` -> `exec` 程序創建流程時存在缺陷。
*   **應對策略 (SOP)**:
    1.  **規避 `Popen`**: 在主應用邏輯中，應盡量避免使用 `subprocess.Popen`。我們最終將重量級的環境準備工作（需要 `subprocess.run`）與主應用的執行（使用 `os.execvpe`）徹底分離。
    2.  **優先使用現代化工具**: 使用如 `uv` 或 `Poetry` 等現代化工具，它們能將複雜的環境操作封裝成單一、原子性的指令 (`uv pip sync`)，能顯著降低觸發此類底層 BUG 的風險。
    3.  **最小化可複現原則**: 當遇到詭異的環境問題時，應立刻建立一個最小化的測試腳本（如我們的 `tools/optimization_probe.py`），在完全隔離的環境中驗證核心指令（如 `uv venv`）是否可用，而不是在複雜的主應用中猜測。

### 1.2. 依賴管理的黃金法則

*   **`pip install -e .` 是解決方案**: 專案初期反覆出現 `ModuleNotFoundError: No module named 'src'`。最終的、也是業界標準的解決方案是：將所有源碼放入 `src/` 目錄，並在安裝依賴後立刻執行 `pip install -e .`，將專案自身註冊為一個可編輯的套件。
*   **警惕間接依賴**: 在 `uvicorn` 啟動時，我們曾遇到 `ModuleNotFoundError: No module named 'click'`。原因是 `click` 是 `uvicorn[standard]` 的一個「額外依賴」，在某些環境下 `uv` 未能正確解析並安裝它。**教訓**：對於核心依賴，不要信任間接的 `extra`，應在 `requirements.in` 文件中明確地、直接地聲明它。
*   **`pip` 的歷史包袱**: 我們曾使用 `--ignore-installed` 參數來強制 `pip` 在虛擬環境中安裝套件，以避免其「跳過」已存在於 Colab 全域環境的套件。**教訓**：在將工具鏈升級到 `uv` 時，我們錯誤地保留了這個 `uv` 不支援的參數，導致了啟動失敗。這提醒我們，在技術棧升級時，必須理解新工具的設計哲學，而不是盲目遷移舊的「補丁」。
*   **`uv` 的性能優勢**: 我們的對照實驗 (`docs/research.md`) 明確證明，使用 `uv venv` 創建虛擬環境，比 Python 內建的 `venv` 模組快 **10 倍**以上。在追求快速啟動和 CI/CD 效率的場景下，應優先採用 `uv`。

---

## 第二章：架構設計與演進

### 2.1. 核心原則：職責分離，保持簡單

專案的穩定性與其架構的簡潔性成正比。我們從多次重構中學到，最可靠的架構永遠是職責最清晰、最單一的那個。

*   **從 GoTTY/API 到資料庫：一次終極進化**:
    *   **失敗的嘗試**: 我們曾嘗試建立一個 GoTTY + API 的複雜架構，讓前端透過 API 輪詢後端狀態。這個架構引入了多個失敗點（網路、程序間通訊、狀態文件讀寫延遲），且除錯極其困難，任何一個環節出錯都會導致「黑洞」。
    *   **成功的頓悟**: 我們最終放棄了這個複雜的架構，回歸到最簡單、最可靠的技術：**SQLite 資料庫**。
        *   **後端 (`launch.py`)**: 成為一個純粹的「工人」，只負責執行任務，並將所有狀態和日誌寫入共享的 `state.db`。它不關心顯示。
        *   **前端 (`colab_runner.py`)**: 成為一個純粹的「顯示器」，每秒從 `state.db` 讀取最新狀態並重新繪製儀表板。
    *   **教訓**: **當一個架構變得過於複雜、難以除錯時，最好的解決方案往往不是在上面添加更多的補丁，而是回歸第一性原理，尋找一個更簡單、更直接的核心。**

*   **環境準備 vs. 應用啟動**:
    *   **失敗的嘗試**: 最初，`start_api_service.py` 腳本被設計為每次啟動都從頭建立 venv、安裝依賴。這不僅效率低下，而且極不穩定。
    *   **成功的重構**: 我們將兩者徹底分離。`colab_runner.py` 作為「編排者」，負責一次性地、同步阻塞地準備好環境；而 `start_api_service.py` 則成為一個輕量級的「啟動器」，只負責用 `os.execvpe` 啟動應用。

### 2.2. 防禦性設計：預見失敗

*   **看門狗 (Watchdog) 機制【已處理】**: 對於長時間運行的背景服務，必須假設它可能卡死。我們曾提出一個基於日誌輸出的「看門狗」理論。在 V68 版本中，此理論已被成功實作並交付了一個名為 `scripts/safe_runner.py` 的通用安全啟動器。它透過監控子進程的日誌輸出，並在指定時間內（預設15秒）無響應時自動終止目標，為所有背景服務提供了一層關鍵的穩定性保障。
*   **下載檔案隔離**: 應用程式在運行中產生的所有檔案，都必須儲存到一個與源碼完全隔離的目錄中，並透過 `config.json` 來配置路徑。這可以有效防止用戶產生的內容污染或破壞運行環境。

---

## 第三章：測試與除錯

### 3.1. 測試的智慧：分層與取捨

*   **E2E 測試是最高保證**: 對於一個涉及多進程、多階段的複雜應用，端對端 (E2E) 測試是驗證其完整生命週期的黃金標準。我們的 `tests/e2e/test_full_lifecycle.py` 和 `test_colab_logic.py` 透過模擬真實的使用者流程，為專案品質提供了最高級別的保證。
*   **對非同步應用的測試要務實**: 我們曾嘗試為一個本身管理著 `asyncio` 事件迴圈的 `launch.py` 腳本編寫整合測試，但陷入了 `pytest-anyio` 的泥潭。**教訓**：測試一個頂層應用的部分功能是非常困難且脆弱的。更務實的方法是：
    1.  為其內部的、**同步的**、純粹的邏輯（如工具函式）編寫穩定的單元測試。
    2.  依靠更宏觀的 E2E 測試來確保整體的整合是正確的。

### 3.2. 除錯的藝術：刨根問底

*   **日誌系統的陷阱**:
    *   **`print` vs `logging`**: 在 FastAPI 或多執行緒應用中，背景執行緒裡的 `print` 輸出會被主框架的日誌系統「吞掉」而無法顯示。**教訓**：所有背景任務都**必須**使用與主框架兼容的 `logging` 模組來記錄關鍵資訊，並在頂層 `try...except` 中捕獲所有異常。
    *   **日誌競爭條件**: 我們曾遇到因「清理舊日誌」和「建立新日誌」的順序錯誤而導致的、極難複現的 `FileNotFoundError`。**教訓**：對檔案系統的操作要特別注意其順序和原子性。
*   **警惕被「吞掉」的錯誤**: 在一次測試中，`shutil.move` 因權限問題拋出例外，但這個例外被一個寬泛的 `except Exception` 區塊和一個被 mock 的函式「吞掉」，導致測試在毫不相關的 `assert` 處失敗。**教訓**：除錯時，要警惕被 mock 的物件或寬泛的 `try...except` 可能隱藏了真正的錯誤根源。
*   **建立你的除錯 SOP**:
    *   **強制無緩衝輸出**: `PYTHONUNBUFFERED=1 python ...`
    *   **用 Python 查 SQLite**: `python -c "import sqlite3; ..."`
    *   **清理殭屍進程**: `kill $(lsof -t -i:<port>)`
    *   將這些命令標準化，能極大提升除錯效率。

### 3.3. Colab UI 開發經驗

*   **「單一繪製」原則**: 為了在 Colab 中實現流暢、無閃爍的動態儀表板，必須遵循「單一繪製」原則：在每次刷新時，將所有要顯示的內容先存入一個 `list` (buffer)，最後只呼叫**一次** `print("\n".join(buffer))` 將完整畫面原子性地輸出。
*   **統一輸出控制權**: 為了解決多執行緒競爭導致的 UI 元素（如代理連結）「閃現後消失」的問題，必須規定只有**單一的** `DisplayManager` 執行緒可以執行 `print` 或 `clear_output`。其他執行緒只能透過更新一個共享的狀態字典來與其溝通。
*   **解耦生命週期**: 為了解決後端執行緒出錯時 UI「凍結」的問題，主執行緒的生命週期不應依賴於任何工作執行緒。主執行訊應只負責保持儲存格存活 (`while True: time.sleep(1)`)，讓 `DisplayManager` 能一直運行並忠實地呈現最終的錯誤狀態。

---

## 第四章：核心啟動器重構與遠端除錯 (V65)

### 4.1. 核心問題：不一致的執行環境

在 V65 的重構中，我們面臨的核心挑戰是 `local_run.py`（本地測試）和 `run/colab_runner.py`（Colab 執行）兩者之間存在各自獨立的、不一致的環境設定邏輯。這導致了一個在本地測試通過，但在 Colab 上卻反覆失敗的惡性循環。

*   **失敗的根源**:
    1.  **依賴清單不同**: `local_run.py` 使用 `requirements/base.txt`，而 `colab_runner.py` 使用 `requirements/requirements-core.txt`，後者缺少了 `python-multipart` 等關鍵套件。
    2.  **環境建立方式不同**: 一個使用 Python 內建的 `venv` 模組，另一個則嘗試直接安裝。這在 Colab 特殊的 Python 環境中引發了 `ensurepip` 錯誤。
*   **最終的頓悟**: 任何形式的「兩套邏輯」都註定會失敗。我們必須建立一個**單一事實來源 (Single Source of Truth)**。

### 4.2. 解決方案：引入「核心啟動器」架構

我們將所有與環境設定和應用啟動相關的複雜邏輯，全部抽離並封裝到一個全新的 `scripts/launch.py` 腳本中。

*   **職責劃分**:
    *   **`scripts/launch.py`**: 成為唯一的「工人」，負責建立 venv、安裝所有依賴、啟動伺服器。
    *   **`local_run.py` / `run/colab_runner.py`**: 成為純粹的「編排者」，它們的職責被簡化為**呼叫 `scripts/launch.py`**。
*   **教訓**: **架構的可靠性來自於其一致性。透過消除重複邏輯並建立單一入口點，我們從根本上解決了環境差異問題。**

### 4.3. 遠端除錯的藝術：迭代與驗證

在重構過程中，我們依然遇到了一系列看似簡單但極其隱蔽的錯誤。解決這些問題的過程，沉澱出了一套可靠的遠端除錯方法論。

1.  **問題：`git clone` 的程式碼不是最新版**
    *   **現象**: 我們在本地修復了 `scripts/launch.py`，但在 Colab 上執行的仍然是舊的、有問題的版本。
    *   **原因**: 我們的整合測試 (`tests/test_launcher.py`) 錯誤地從遠端 `git clone` 專案，而不是測試本地工作區的修改。
    *   **解決方案**: 將測試邏輯從 `git clone` 改為 `shutil.copytree`，確保測試永遠驗證的是**當前未提交的程式碼**。這是 CI/CD 的最佳實踐。

2.  **問題：`uv venv` 後找不到 `pip`**
    *   **現象**: 在 `uv venv` 成功後，執行 `.venv/bin/pip` 報錯 `No such file or directory`。
    *   **原因**: `uv venv` 在某些模式下只建立環境骨架，不保證安裝 `pip`。
    *   **解決方案**: 在 `launch.py` 中，`uv venv` 執行後，明確加入一步 `uv pip install --python <venv_python> pip wheel` 來**手動引導 `pip` 的安裝**。

3.  **問題：在 venv 中找不到 `uv`**
    *   **現象**: 在引導 `pip` 之後，嘗試用 `.venv/bin/uv` 安裝其他依賴時失敗。
    *   **原因**: `uv` 是一個全域工具，它不會被安裝到 venv 內部。
    *   **解決方案**: 所有後續的 `uv` 命令都必須呼叫**全域的 `uv`**，並使用 `--python <venv_python>` 參數來**指定目標虛擬環境**。

4.  **問題：Colab `eval_js` 超時**
    *   **現象**: 獲取代理連結時，`eval_js` 偶爾會拋出 `Timed out waiting for output iframe load` 錯誤，並導致重試邏輯失效。
    *   **原因**: Colab 前後端通訊不穩定，且我們的 `except` 區塊沒有正確地 `time.sleep`。
    *   **解決方案**: 重構重試迴圈，確保在 `except` 區塊中**也執行 `time.sleep`**，給予 Colab 前端足夠的緩衝時間。

### 4.4. 最終 SOP：探針與測試驅動

*   **環境探針**: 我們為 `launch.py` 加入了「環境探針」，在啟動時打印所有關鍵版本號和路徑。這在除錯時被證明是無價的，它讓我們第一時間就能「看到」遠端環境的全貌。
*   **測試驅動開發**: 這次重構的成功，`tests/test_launcher.py` 功不可沒。它讓我們能夠在本地快速、可靠地複現並驗證 Colab 環境中才會出現的錯誤，將除錯週期從幾十分鐘縮短到幾十秒。**教訓：為最不穩定的部分（環境設定）編寫最穩定的測試，是最高效的投資。**

---

這份文件是我們團隊智慧的結晶。每一次的成功都值得慶祝，每一次的失敗都值得被記錄和學習。希望它能成為指引我們未來航程的燈塔。
