# 技術文件：V55 Colab 互動式執行器的設計原理與除錯歷程

本文檔旨在深入剖析 `run/colab_runner.py` V55 版本的核心設計思想與開發過程中遇到的挑戰與解決方案。這份文件記錄了我們如何從一個基礎的執行腳本，透過多次迭代，最終演進為一個功能強大、穩定可靠且使用者體驗良好的作戰指揮中心。

## 第一部分：V55「純文字動態儀表板」設計原理

V55 版本儀表板的核心目標是，在 Colab 這種特殊的日誌流環境中，實現一個**資訊清晰、即時更新且視覺無干擾**的監控介面。我們最終採納的「單一繪製」架構，是借鑒了專業 CLI 工具和使用者提供的 `FRED` 工具範本的設計精髓，並圍繞 Colab 的 `clear_output` 函式特性而打造的。

其穩定運作依賴三大技術支柱的完美協作：

### 支柱一：畫布清潔工 `clear_output(wait=True)`

這是實現「不洗版」更新的基石，它來自 `IPython.display` 函式庫，是專為在 Jupyter / Colab 環境中控制輸出而生的。

- **`clear_output()`**：它的作用很單純，就是立即清除目前這個儲存格(Cell)的所有輸出內容。
- **`wait=True` 參數**：這是精髓所在。如果沒有這個參數，系統會先「清除畫面」，然後再花時間去準備「要顯示的新內容」，中間的延遲會導致肉眼可見的**閃爍**。加上 `wait=True` 後，系統會等到所有新的輸出內容都準備好之後，**才一次性地清除舊畫面並顯示新畫面**。這確保了更新過程的原子性和平滑性。

在我們的程式碼中，`DisplayManager` 的 `_run` 方法在每一次迴圈開始時，第一件事就是呼叫 `clear_output(wait=True)`，確保接下來的 `print` 都是在一個乾淨的「畫布」上進行繪製。

### 支柱二：獨立的藝術家 `threading` (多執行緒)

為了避免 UI 更新被耗時的後端任務（如安裝依賴、啟動伺服器）卡住，我們將程式的職責徹底分離，並交由不同的執行緒處理：

1.  **`ServerManager` (工人執行緒)**：這是背景的工作核心。它負責執行所有耗時的阻塞性任務，包括：建立虛擬環境、安裝依賴、啟動 Uvicorn 伺服器，並監聽伺服器的日誌以判斷其是否就緒。它不關心任何畫面的呈現。

2.  **`DisplayManager` (情報官/畫家執行緒)**：這是使用者介面的唯一控制者。它的工作極其單純：以固定的高頻率（例如每 0.5 秒）不斷地「清理並重繪」儀表板。它不關心數據是怎麼來的，只負責忠實地呈現當前的最新狀態。

3.  **主執行緒 (指揮官)**：它的職責被簡化到極致。在初始化並啟動上述兩個管理器後，它只做兩件事：
    - 等待 `ServerManager` 發出的「伺服器已就緒」信號。
    - 收到信號後，呼叫 Colab API 獲取代理網址，並將其更新到共享狀態中。
    - 進入一個無限迴圈，保持儲存格存活，直到使用者手動中斷。

這種架構確保了即使 `ServerManager` 正在執行一個長達數分鐘的任務，`DisplayManager` 依然能歡快地刷新畫面，即時更新 CPU、RAM 和執行時間等資訊。

### 支柱三：共享的公告欄 (`stats_dict` & `LogManager`)

既然多個執行緒各自獨立，它們需要一個安全可靠的方式來溝通。我們使用了一個共享的 Python 字典 `shared_stats` 和一個自訂的 `LogManager` 作為「資訊公告欄」。

- **`stats_dict` (狀態字典)**：
  - **寫入者**：`ServerManager` 在其執行流程的關鍵節點，會去更新這個字典的內容，例如 `self._stats['status'] = "🚀 正在啟動伺服器..."`。主執行緒在獲取到代理網址後，也會更新 `shared_stats['proxy_url'] = url`。
  - **讀取者**：`DisplayManager` 在每次重繪畫面時，會來讀取這個字典的最新值，例如 `f"🔥 狀態: {self._stats.get('status', '初始化...')}"`，並將其繪製出來。

- **`LogManager` (日誌管理器)**：
  - **解決日誌風暴**: 程式中任何部分產生的日誌，都不是直接 `print` 出來，而是呼叫 `log_manager.log(...)`。日誌被存入一個內部有長度限制的 `collections.deque` 佇列中。
  - **實現優雅滾動**: 當新的日誌進入佇列時，如果佇列已滿，最舊的日誌會自動被擠出。這就實現了使用者所期望的「日誌超過N行，最舊的自動消失」的滾動效果。
  - **實現等級過濾**: `DisplayManager` 在繪製時，會先呼叫 `log_manager.get_display_logs()`，此方法會根據使用者在 Colab 表單中勾選的 `SHOW_LOG_LEVEL_*` 選項，只回傳需要被顯示的日誌。

### 最終的「單一繪製」原則

我們在除錯中發現，即使使用了 `clear_output(wait=True)`，多次、零碎的 `print` 呼叫依然會導致閃爍。最終的解決方案是採納「單一繪製」原則：

1.  在 `DisplayManager` 的每一次刷新迴圈中，先建立一個空列表 `output_buffer`。
2.  將標題、分隔線、每一條格式化後的日誌、狀態行等**所有要顯示的內容，都先作為字串存到這個列表中**。
3.  在迴圈的最後，使用 `print("\n".join(output_buffer), flush=True)` **只呼叫一次 `print`**，將這個完整的畫面一次性地、原子性地印到螢幕上。

這個方法確保了對 Colab 輸出的操作是不可分割的，完美配合了 `clear_output` 的機制，最終實現了如原生應用般流暢、無閃爍的動態儀表板。

---

## 第二部分：關鍵除錯歷程與解決方案

在將腳本從 V44 迭代至 V55 的過程中，我們遇到並解決了數個關鍵的、非常具有代表性的環境與程式碼問題。

### 問題一：`ModuleNotFoundError: No module named 'click'`
- **現象**: 環境準備成功，但在啟動 Uvicorn 時，腳本因找不到 `click` 套件而失敗。
- **初步分析**: 懷疑 `requirements/requirements-core.txt` 中缺少 `click` 依賴。
- **深入分析**: 檢查後發現，`click` 是 `uvicorn[standard]` 的一個「額外依賴」。理論上 `uv pip sync` 應該會自動安裝它。但它在 Colab 環境中沒有被正確安裝，顯示 `uv` 在此環境下對於 extra 依賴的解析可能存在問題。
- **解決方案**: 我們不再依賴間接的 extra，而是在 `requirements/requirements-core.txt` 中**明確地、直接地加入 `click`**。這為安裝器提供了最直接的指令，確保了它在任何情況下都會被安裝。

### 問題二：`No module named pip`
- **現象**: 在某次重構後，環境準備在「安裝依賴」步驟失敗，報錯顯示虛擬環境中找不到 `pip` 模組。
- **分析**: `uv venv` 指令在 Colab 環境中有時會建立一個極度精簡的、不包含 `pip` 和 `wheel` 的虛擬環境。這使得後續所有基於 `pip` 的安裝指令都無法執行。
- **解決方案**: 我們在 `uv venv` 成功建立環境後，立刻加入了一個「**引導程序 (Bootstrapping)**」步驟。
  1.  手動為 `subprocess.run` 建立一個啟用了新虛擬環境的 `env` 字典。
  2.  執行 `uv pip install pip wheel` 指令，使用 `uv` 自己，為這個新環境「裝回」`pip`。
  3.  這個修正確保了無論 `uv venv` 建立的環境多麼精簡，我們都能手動保證 `pip` 的存在，從而讓後續的依賴安裝流程得以順利進行。

### 問題三：UI 閃爍與代理連結消失
- **現象**: 儀表板在刷新時會出現肉眼可見的閃爍，並且在伺服器就緒後，打印出來的代理連結只會出現一瞬間然後就消失。
- **分析**: 這是典型的**多執行緒競爭(Race Condition)**問題。
  - **主執行緒**在伺服器就緒後，只 `print` 一次代理連結。
  - **顯示執行緒**在背景以 0.5 秒的頻率，不斷地執行「清除畫面 -> 重繪儀表板」。
  - 結果就是，主執行緒剛印出連結，顯示執行緒的下一次刷新就清除了整個畫面，導致連結消失。
- **解決方案**: **統一輸出控制權**。
  1.  我們嚴格規定，只有 `DisplayManager` 可以執行 `print` 或 `clear_output`。
  2.  主執行緒在獲取到代理連結後，**不做任何打印**，而是將 URL 字串存入共享的 `shared_stats` 字典中。
  3.  `DisplayManager` 在每次重繪時，都會檢查 `shared_stats` 中是否有 URL。一旦發現，它就會負責將這個 URL 作為儀表板的一部分繪製出來。
  4.  這徹底解決了競爭問題，確保了畫面的穩定與資訊的持久顯示。

### 問題四：狀態行在程式出錯時「凍結」
- **現象**: 如果 `ServerManager` 執行緒在設定環境時出錯崩潰，整個儀表板（特別是即時狀態行）會凍結在出錯前的最後一刻，無法更新最終的「錯誤」狀態。
- **分析**: 這是**執行緒生命週期耦合**的問題。主執行緒的存活，錯誤地依賴於 `ServerManager` 執行緒的存活 (`while server_manager._thread.is_alive()`)。一旦 `ServerManager` 死亡，主執行緒就退出，並在 `finally` 中關閉了 `DisplayManager`。
- **解決方案**: **解耦生命週期**。
  1.  我們將主執行緒的迴圈修改為一個簡單的 `while True: time.sleep(1)`。
  2.  它的唯一職責就是保持 Colab 儲存格運行，從而保證 `DisplayManager` 能一直活著。
  3.  這樣，即使 `ServerManager` 崩潰，`DisplayManager` 依然可以從 `shared_stats` 中讀取到 `ServerManager` 更新的最終錯誤狀態，並忠實地將其顯示在儀表板上，直到使用者手動中斷整個程式。

---

這份文件記錄了我們如何透過細緻的觀察、深入的分析和不斷的迭代，將一個看似簡單的腳本，打造成一個能夠應對複雜環境挑戰的、健壯且優雅的工具。這其中的每一步都體現了軟體工程中對於穩定性、可靠性和使用者體驗的追求。
