# 📖 端對端 (E2E) 測試框架設計指南

**文件作者：** Jules (AI 軟體工程師)
**最後更新：** 2025年8月2日

## 一、 測試層次與定位

在一個成熟的軟體專案中，測試通常分為幾個層次，各司其職：

1.  **跑單元測試 (Unit Tests)**：
    *   **目的**：在本地快速驗證單一函式或類別的邏輯正確性。
    *   **特點**：速度快、不依賴外部服務（如資料庫、網路）。
    *   **位置**：`tests/unit/`

2.  **跑整合測試 (Integration Tests)**：
    *   **目的**：確認新功能在完整的、模擬 Colab 的流程中也能正常運作。
    *   **特點**：模擬真實的使用者場景，驗證多個模組之間的互動。
    *   **位置**：`tests/integration/`

本文件所介紹的 `tests/e2e/test_colab_logic.py`，正是我們專案中**最權威的整合測試**。它的目標是在一個隔離且可控的環境中，完整地模擬 `colab_runner.py` 的核心邏輯，並驗證整個後端服務的反應。

---

## 二、 核心設計原則：遵循嚴格的環境分離

此 E2E 測試框架的設計，嚴格遵循了您提出的四點環境建立與執行原則，以確保其在任何機器上都具備極高的穩定性與可複現性。

1.  **獨立虛擬環境**:
    *   **實踐**: 腳本會檢查並使用 Python 內建的 `venv` 模組，在專案根目錄下建立一個名為 `.venv` 的獨立虛擬環境。所有後續操作的依賴都安裝於此，與系統全域的 Python 環境完全隔離。

2.  **不使用 `source` 或 `activate`**:
    *   **實踐**: 整個流程中，您不會看到任何 `source .venv/bin/activate` 的命令。這是一種更現代、更可靠的作法，避免了因 shell 環境不相容而導致的問題。

3.  **使用絕對路徑直譯器**:
    *   **實踐**: 所有需要以 Python 執行的命令（例如安裝依賴、啟動後端伺服器），都明確地透過呼叫 `.venv/bin/python` 這個絕對路徑的直譯器來執行。這確保了命令一定是在我們指定的虛擬環境中運行。

4.  **兩階段執行**:
    *   **實踐**: 腳本採用了巧妙的「自我引導」設計，完美地實現了兩階段執行：
        *   **第一階段 (環境準備)**: 使用系統的 Python 啟動，此階段的唯一任務是執行上述的 1-3 步，建立 venv 並安裝依賴。完成後，它會使用 `.venv/bin/python` **重新啟動自己**。
        *   **第二階段 (邏輯測試)**: 當腳本第二次啟動時，它已經身處於一個萬事俱備的虛擬環境中，此時才開始執行真正的測試邏輯。

---

## 三、 健壯性核心：看門狗 (Watchdog) 超時機制

在自動化測試中，最棘手的問題之一就是程序因未知原因「卡死」(hang)，導致整個 CI/CD 流程超時失敗，且難以追查原因。

為了從根本上解決這個問題，我們在啟動後端伺服器的 `start_server` 函式中，實作了一個健壯的「看門狗」機制。

### **運作邏輯詳解**：

1.  **啟動定時器**: 在 `subprocess.Popen` 呼叫後，一個 `threading.Timer` 會被立即啟動，設定為 **10 秒**後觸發 `handle_timeout` 函式。
    ```python
    watchdog_timer = threading.Timer(10.0, handle_timeout)
    watchdog_timer.start()
    ```

2.  **監聽日誌輸出**: 腳本會進入一個 `for` 迴圈，逐行讀取後端伺服器程序的標準輸出 (`stdout`)。
    ```python
    for line in iter(server_process.stdout.readline, ''):
        # ...
    ```

3.  **重置定時器 (餵狗)**: **每當成功讀取到任何一行日誌**，無論內容為何，腳本都會**立刻重置看門狗定時器**。這代表取消舊的 10 秒倒數，並啟動一個全新的 10 秒倒數。
    ```python
    reset_watchdog() # 重新計時
    ```
    這個動作俗稱「餵狗」(feeding the dog)。只要後端服務持續有日誌輸出（代表它沒有卡死），這個定時器就永遠不會被觸發。

4.  **超時觸發**: 如果後端服務因任何原因卡住（例如，死鎖、等待無法滿足的資源等），導致在 **10 秒內沒有任何新的日誌行出現**，那麼 `handle_timeout` 函式將會被執行。

5.  **保證終止程式**: `handle_timeout` 函式會：
    *   打印一條清晰的錯誤訊息，指明測試因超時而失敗。
    *   使用 `server_process.kill()` 強制終止後端伺服器子程序。
    *   使用 `os._exit(1)` 以非零錯誤碼**立即、強制地退出整個測試腳本**。
    ```python
    def handle_timeout():
        print("❌ 錯誤: 10 秒內沒有收到任何日誌輸出，測試超時！")
        if server_process:
            server_process.kill() # 終止子程序
        os._exit(1) # 強制退出主程序
    ```

這個機制的引入，為我們的 E2E 測試提供了最終的穩定性保障：**它保證了測試在任何情況下，要麼成功，要麼在 10 秒的靜默後快速失敗，絕不會無限期地等待下去。**
